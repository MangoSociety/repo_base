#готово 

Theme : #kotlin #nested #inner
Title: Расскажите про отличия nested class и inner class
Sphere: #android 

### Content

вложенные классы могут быть объявлены как `nested class` (вложенный класс) или `inner class` (внутренний класс), каждый из которых имеет свои особенности и используется в зависимости от необходимости доступа к членам внешнего класса.

#### Nested Class (Вложенный класс)

- **Определение**: `nested class` в Kotlin объявляется без использования модификатора `inner`. Он ведет себя подобно статическому вложенному классу в Java.
- **Доступ**: `nested class` не имеет доступа к членам внешнего класса. Это означает, что он не может напрямую обращаться к свойствам и методам экземпляра внешнего класса.
- **Использование**: Такие классы обычно используются, когда вложенный класс должен работать независимо от экземпляра внешнего класса, или когда он служит вспомогательным классом, не требующим доступа к состоянию внешнего класса.

Пример `nested class`:
```kotlin
class Outer {
    private val outerProperty = "Внешнее свойство"
    
    class Nested {
        fun nestedFunction() = "Функция Nested класса"
    }
}

```

#### Inner Class (Внутренний класс)

- **Определение**: `inner class` объявляется с использованием модификатора `inner`. Это позволяет ему иметь доступ к членам внешнего класса.
- **Доступ**: `inner class` сохраняет ссылку на объект внешнего класса, что позволяет ему обращаться к его свойствам и методам, включая приватные.
- **Использование**: Внутренние классы применяются, когда необходим доступ к состоянию внешнего класса или когда вложенный класс тесно связан с внешним классом.

Пример `inner class`:

```kotlin
class Outer {
    private val outerProperty = "Внешнее свойство"
    
    inner class Inner {
        fun innerFunction() = "Доступ к $outerProperty из Inner класса"
    }
}

```

#### Основные отличия

1. **Доступ к членам внешнего класса**: `inner class` имеет доступ к членам внешнего класса, в то время как `nested class` не имеет.
2. **Ссылка на внешний класс**: `inner class` неявно содержит ссылку на объект внешнего класса, что влияет на использование памяти и может быть важно при рассмотрении вопросов производительности и жизненного цикла объектов.
3. **Модификатор `inner`**: Только `inner class` требует явного объявления с помощью модификатора `inner`. `Nested class` объявляется без него и ведет себя как статический вложенный класс в Java.

Выбор между `nested` и `inner` классом зависит от задачи: если вам нужен доступ к состоянию внешнего класса, используйте `inner class`. Если такой необходимости нет, предпочтительнее использовать `nested class` для избежания ненужных зависимостей и потенциальных утечек памяти.
### External Link

- 

### Internal Link

- ....