#готово 

Theme : #golang #common 
Title: Что будет, если читать из закрытого канала? сколько значений возвращает одно чтение из канала? А почему range-чтение из канала возвращает одно?
Sphere : #backend

### Content

Если читать из закрытого канала, чтение завершится успешно, и будет возвращено zero value для типа, который передавался через канал. При чтении из закрытого канала функция чтения возвращает два значения: само значение и булево значение, указывающее, был ли канал закрыт.

Пример чтения из закрытого канала:

```go
package main

import "fmt"

func main() {
    ch := make(chan int)
    close(ch)
    
    value, ok := <-ch
    fmt.Println(value, ok) // 0 false
}
```

Булево значение `ok` будет `false`, если канал закрыт и пуст.

Одно чтение из канала возвращает одно значение, потому что Go каналы передают элементы по одному.

Range-чтение из канала возвращает одно значение, потому что range по каналу продолжается до тех пор, пока канал не будет закрыт и все значения не будут считаны. Когда канал закрыт, range завершает итерацию. Пример:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int)
    done := make(chan struct{})

    go func() {
        for i := 0; i < 5; i++ {
            ch <- i
            time.Sleep(time.Millisecond * 100)
        }
        close(done)
    }()

    go func() {
        for {
            select {
            case value, ok := <-ch:
                if !ok {
                    return
                }
                fmt.Println(value)
            case <-done:
                close(ch)
                return
            }
        }
    }()

    time.Sleep(time.Second) // чтобы успел напечатать значения
}

```

В этом примере канал закрывается читателем после получения сигнала `done` от писателя. Это позволяет избежать гонки за доступ к каналу и сохраняет консистентность.

### External Link



### Internal Link

- 