#готово 

Theme : #android #coroutine 
Title: Какая разница между coroutineScope и CoroutineScope ?
Sphere: #mobile 

### Content

Разница между `coroutineScope` и `CoroutineScope` в Kotlin заключается в их предназначении, контексте использования и поведении при работе с корутинами. Они оба используются для управления асинхронным кодом, но различаются по ряду аспектов:

### `coroutineScope`

1. **Функция высшего порядка**:
   - `coroutineScope` — это функция высшего порядка, которая предоставляет область видимости для корутин и гарантирует их завершение перед выходом из функции.

2. **Suspending функция**:
   - `coroutineScope` является `suspend` функцией, поэтому она может вызываться только из другой `suspend` функции или из корутины.

3. **Гарантия завершения корутин**:
   - Все корутины, запущенные внутри `coroutineScope`, должны завершиться до завершения самой функции. Это обеспечивает структурированную конкурентность и предотвращает утечки памяти.

4. **Пример использования**:
   ```kotlin
   import kotlinx.coroutines.*

   suspend fun exampleCoroutineScope() {
       coroutineScope {
           launch {
               delay(1000)
               println("Task 1 completed")
           }
           launch {
               delay(2000)
               println("Task 2 completed")
           }
       }
       println("All tasks completed")
   }

   fun main() = runBlocking {
       exampleCoroutineScope()
   }
   ```
   В этом примере программа не выйдет из `exampleCoroutineScope` до завершения всех запущенных корутин.

### `CoroutineScope`

1. **Интерфейс**:
   - `CoroutineScope` — это интерфейс, который можно реализовать для создания настраиваемого контекста выполнения корутин.

2. **Использование для создания областей видимости корутин**:
   - `CoroutineScope` используется для создания областей видимости корутин с определенным контекстом, включающим `Job` и `Dispatcher`.

3. **Создание и управление корутинами**:
   - `CoroutineScope` позволяет запускать корутины, используя функции расширения, такие как `launch` и `async`.

4. **Пример использования**:
   ```kotlin
   import kotlinx.coroutines.*

   class MyScope : CoroutineScope {
       private val job = Job()
       override val coroutineContext = Dispatchers.Default + job

       fun clear() {
           job.cancel()
       }
   }

   fun main() {
       val myScope = MyScope()

       myScope.launch {
           delay(1000)
           println("Task completed")
       }

       myScope.clear()
   }
   ```
   В этом примере создается пользовательский `CoroutineScope`, который управляет корутинами и позволяет отменить их через `clear`.

### Ключевые отличия

1. **Тип**:
   - `coroutineScope` — функция.
   - `CoroutineScope` — интерфейс.

2. **Область применения**:
   - `coroutineScope` используется для обеспечения структурированной конкурентности внутри `suspend` функций.
   - `CoroutineScope` используется для создания настраиваемых областей видимости корутин с определенным контекстом выполнения.

3. **Завершение**:
   - `coroutineScope` гарантирует, что все запущенные внутри корутины завершатся перед выходом из функции.
   - `CoroutineScope` не гарантирует автоматическое завершение корутин, и разработчик должен управлять их завершением вручную.

4. **Контекст использования**:
   - `coroutineScope` полезен для локального управления корутинами в `suspend` функциях.
   - `CoroutineScope` полезен для создания долгоживущих областей видимости корутин, таких как в `ViewModel` или других компонентах с собственным жизненным циклом.

### Итог

- Используйте `coroutineScope` для временных областей видимости корутин внутри `suspend` функций.
- Используйте `CoroutineScope` для создания областей видимости корутин с определенным контекстом и для долгоживущих задач.

### External Link

- 

### Internal Link

- ....