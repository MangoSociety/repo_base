#готово 

Theme : #golang #scheduler
Title: Расскажи про глобальную и локальную очереди
Sphere : #backend

### Content

В планировщике Go используется две основные очереди для управления горутинами: глобальная очередь и локальные очереди процессоров (P). Эти очереди помогают эффективно распределять горутины между процессорами и обеспечивают балансировку нагрузки.

### Глобальная очередь

- **Назначение**: Хранит горутины, которые еще не были назначены никакому конкретному процессору (P) или были освобождены из-за нехватки локальных очередей.
- **Использование**: Когда процессор (P) не имеет готовых горутин в своей локальной очереди, он может брать горутины из глобальной очереди.
- **Балансировка**: Обеспечивает, чтобы все процессоры (P) могли получать задачи для выполнения, даже если локальные очереди пусты.

### Локальные очереди

- **Назначение**: Каждый процессор (P) имеет свою собственную локальную очередь, где хранятся горутины, готовые к выполнению на этом процессоре.
- **Использование**: Планировщик сначала ищет горутины в локальной очереди процессора (P). Это позволяет минимизировать накладные расходы на переключение контекста и улучшить кэш-производительность.
- **Вороство (Work Stealing)**: Если локальная очередь процессора (P) пуста, процессор может "украсть" горутины из локальной очереди другого процессора или взять горутины из глобальной очереди.

### Принцип работы

1. **Создание горутин**:
   - Новые горутины сначала добавляются в глобальную очередь или сразу в локальную очередь текущего процессора (P), если это возможно.

2. **Планирование выполнения**:
   - Процессор (P) сначала проверяет свою локальную очередь. Если в ней есть готовые горутины, он выполняет их.
   - Если локальная очередь пуста, процессор пытается "украсть" горутины из локальных очередей других процессоров.
   - Если и там горутин нет, процессор обращается к глобальной очереди.

3. **Вороство горутин**:
   - Процессоры (P) регулярно проверяют очереди других процессоров, чтобы украсть горутины и избежать простаивания. Это обеспечивает балансировку нагрузки и эффективное использование ресурсов.

### Пример

Для демонстрации работы планировщика на практике можно использовать простую программу:

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func worker(id int) {
    for i := 0; i < 5; i++ {
        fmt.Printf("Worker %d is running\n", id)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    runtime.GOMAXPROCS(4) // Устанавливаем использование четырех процессоров

    for i := 1; i <= 10; i++ {
        go worker(i)
    }

    time.Sleep(1 * time.Second)
    fmt.Println("Main function completed")
}
```

### Важные моменты

- **Глобальная очередь** обеспечивает резерв готовых горутин для всех процессоров, что предотвращает простаивание процессоров, если их локальные очереди пусты.
- **Локальные очереди** минимизируют накладные расходы на переключение контекста и улучшают кэш-производительность, так как горутины, выполняемые на одном и том же процессоре, могут более эффективно использовать кэш данных.
- **Work Stealing** гарантирует, что ресурсы процессора используются максимально эффективно, перемещая задачи между процессорами для равномерной загрузки.

### External Link



### Internal Link

- 