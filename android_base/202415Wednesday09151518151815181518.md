#готово 

Theme : #golang #scheduler
Title: В чем разница между вытесняющим и кооперативным планировщиком?
Sphere : #backend

### Content

### Вытесняющий планировщик

**Как работает**:
- **Прерывание выполнения**: Вытесняющий планировщик может прерывать выполнение текущей задачи для переключения на другую задачу.
- **Таймеры и аппаратные прерывания**: Использует таймеры и аппаратные прерывания для управления временем выполнения задач.
- **Автоматическое управление**: Планировщик сам решает, когда прервать выполнение текущей задачи.

**Преимущества**:
- **Равномерное распределение ресурсов**: Обеспечивает более равномерное распределение ресурсов между задачами.
- **Предсказуемость**: Снижает вероятность того, что одна задача будет монополизировать CPU.

**Недостатки**:
- **Накладные расходы**: Прерывания и переключение контекста добавляют накладные расходы.
- **Сложность реализации**: Требует более сложной реализации планировщика.

### Кооперативный планировщик

**Как работает**:
- **Добровольное уступание**: Задачи должны добровольно уступать управление, вызывая специальные функции или достигая определенных точек выполнения.
- **Контроль задачи**: Планировщик не прерывает задачи автоматически, задачи сами должны передавать управление планировщику.

**Преимущества**:
- **Меньшие накладные расходы**: Отсутствие принудительных прерываний снижает накладные расходы на переключение контекста.
- **Простота реализации**: Проще реализовать и отладить.

**Недостатки**:
- **Неравномерное распределение ресурсов**: Если задачи не уступают управление добровольно, они могут монополизировать CPU.
- **Требования к задачам**: Задачи должны быть разработаны с учетом необходимости уступать управление.

### Пример в контексте Go

В Go используется вытесняющий планировщик:

- **Вытесняющий планировщик**: Планировщик Go автоматически прерывает выполнение горутин, чтобы переключиться на другие, обеспечивая равномерное распределение CPU времени. Это достигается с помощью таймеров и регулярных проверок.

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func worker(id int) {
    for {
        fmt.Printf("Worker %d is running\n", id)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    runtime.GOMAXPROCS(2)

    go worker(1)
    go worker(2)
    go worker(3)

    time.Sleep(1 * time.Second)
}
```

В этом примере планировщик Go автоматически переключается между горутинами, обеспечивая вытесняющую многозадачность.
### External Link



### Internal Link

- 